class MakeAdaptorImp < ScanServiceModel
	def initialize(document)
	$methodPrototypeList=""
	$methodSkeletonList=""
	$signalPrototypeList=""
	$signalSkeletonList=""
	$signalConnectionList=""
	filename="#{$outdir}#{$rootname}_adaptor_imp.h"
  @file=open(filename, 'w')
	@document=document
	@Primitive={
	'BYTE' => "uint8_t",
	'BOOLEAN' => "bool",
	'INT16' => "int16_t",
	'UINT16' => "uint16_t",
	'INT32' => "int32_t",
	'UINT32' => "uint32_t",
	'INT64' => "int64_t",
	'UINT64' => "uint64_t",
	'DOUBLE' => "double",
	'STRING' => "std::string"
	}
	@header = <<'SINGLE_QUOTED'
/*
 *	This file was automatically generated by BindingTool; DO NOT EDIT!
 *  Code produced automatically widh BindingTool Rel. #{$bindingToolRel}
 */

#ifndef __BindingTool__#{$rootname}_adaptor_imp_h__ADAPTOR_MARSHAL_H
#define __BindingTool__#{$rootname}_adaptor_imp_h__ADAPTOR_MARSHAL_H

#include \"#{$rootname}_adaptor.h\"
#include \"#{$rootname}_dataType.h\"

#include \"CMMString.h\"

SINGLE_QUOTED

	@footer =	<<'SINGLE_QUOTED'

#endif /*__BindingTool__#{$rootname}_adaptor_imp_h__ADAPTOR_MARSHAL_H*/
SINGLE_QUOTED

	@glueclasstemplate = <<'SINGLE_QUOTED'
class #{@classname}_adaptor_imp : public #{@classname}_adaptor
{
public:

    #{@classname}_adaptor_imp() : #{@classname}_adaptor() {}

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */

    // must be implemented with in and out parameters

#{@methodList}

    /* signal emitters for this interface
     */

    // only input parameters
    // automatic conversion from const com_MM_test_structtest& to const ::DBUS::Struct& done by dynamic cast
    // conversion to const CMMString& to stl::string explicit or with dynamic cast (not implemented yet)

#{@signalList}

private:

  // called from DBus
  // input parameters with automatic conversion by copy constructor
  // output parameters conversion must be managed by temporary variable (for all custom type like com_MM_test_structtest and CMMString )

#{@privatemethodList}


};
SINGLE_QUOTED

@privatemethodtemplate = <<'SINGLE_QUOTED'
	int #{@methodname}(#{@arglist})
	{
#{@declarationList}
		int32_t l_ret = #{@methodname}_imp(#{@imparglist});
#{@assignList}
		return (l_ret);
	}
SINGLE_QUOTED

		@file.puts eval( '"' + @header + '"')
	end

	def iterateDoEnd
		@file.puts eval( '"' + @footer + '"')
		@file.close
	end

	def interfaceDoEnd
		@file.puts eval( '"' + @glueclasstemplate + '"')
	end

	def argDoIn
		if @argdirection == "in" then
			cpptype=@argtype
			if @Primitive[cpptype].nil? then
				if $enum[cpptype].nil? then
					cpptype = "#{$MarelliNamespace}_#{@servicename}_#{cpptype}"
				else
					cpptype = "uint32_t"
				end
			else
				cpptype = @Primitive[cpptype]
			end
			@arglist += @argseparator+"const #{cpptype} &p_#{@argname}"
			@argseparator = ", "
		end
	end

	def argDoOut
		if @argdirection == "out" then
			cpptype=@argtype
			if @Primitive[cpptype].nil? then
				if $enum[cpptype].nil? then
					cpptype = "#{$MarelliNamespace}_#{@servicename}_#{cpptype}"
				else
					cpptype = "uint32_t"
				end
			else
				cpptype = @Primitive[cpptype]
			end
			@arglist += @argseparator+"#{cpptype} &p_#{@argname}"
			@argseparator = ", "
		end
	end

	def argDoInDBUS
		impname = @argname
		if @argdirection == "in" then
			if @Primitive[@argtype].nil? then
				if $enum[@argtype].nil? then
					cpptype = $dataType[@argtype]['cpp']
				else
					cpptype = "uint32_t"
				end
			else
				cpptype = @Primitive[@argtype]
			end
			@arglist += @argseparator+"const #{cpptype} &#{@argname}"
			@argseparator = ", "
			@imparglist += @impargseparator+impname
			@impargseparator = ", "
		end
	end

	def argDoOutDBUS
		impname=@argname
		if @argdirection == "out" then
			if @Primitive[@argtype].nil? then
				if $enum[@argtype].nil? then
					cpptype = $dataType[@argtype]['cpp']
					if cpptype[0,6] == '::DBus' then
						@declarationList += "\t\t#{$MarelliNamespace}_#{@servicename}_#{@argtype} l_tmpOut#{@tmpOutIndex};\n"
						@assignList += "\t\t#{@argname} = l_tmpOut#{@tmpOutIndex};\n"
						impname = "l_tmpOut#{@tmpOutIndex}"
						@tmpOutIndex += 1
					end
				else
					cpptype = "uint32_t"
				end
			else
				cpptype = @Primitive[@argtype]
			end
			@arglist += @argseparator+"#{cpptype} &#{@argname}"
			@argseparator = ", "
			@imparglist += @impargseparator+impname
			@impargseparator = ", "
		end
	end


	def argDoSignal
		if @argdirection == "out" then
			cpptype=@argtype
			if @Primitive[cpptype].nil? then
				if $enum[cpptype].nil? then
					cpptype = "#{$MarelliNamespace}_#{@servicename}_#{cpptype}"
				else
					cpptype = "uint32_t"
				end
				@dbusarglist += @dbusarglistseparator+"p_#{@argname}"
				@dbusarglistseparator=", "
			else
				if @argtype == 'STRING' then
					cpptype = "CMMString"
					@conversionlist += "\t\t\tstd::string l_#{@argname};\n\t\t\tl_#{@argname} = p_#{@argname}.GetBuffer(CMMSTRING_UTF8);"
					@dbusarglist += @dbusarglistseparator+"l_#{@argname}"
					@dbusarglistseparator=", "
				else
				cpptype = @Primitive[cpptype]
				@dbusarglist += @dbusarglistseparator+"p_#{@argname}"
				@dbusarglistseparator=", "
				end
			end
			@arglist += @argseparator+"const #{cpptype} &p_#{@argname}"
			@argseparator = ", "
		end
	end


#definisci la strategia di iterazione sugli elementi contenuti in "Interface"
	def iterateinterfacestrategy(interface)
		@classname="#{$MarelliNamespace}_#{@interfacename}"
		@methodList=""
		@signalList=""
		@privatemethodList=""

#Method
		#definisci la strategia di iterazione sugli elementi contenuti in "Method"
		def self.iteratemethodstrategy(method)

			#stabilisci quale azione eseguire quando si sono acquisiti i dati di un argomento
			#nello specifico caso si considerano solo gli argomenti con direzione "in"
			def self.argDo
				argDoIn
			end
			#quindi iterare sugli argomenti
			iteratearg(method)

			#stabilisci quale azione eseguire quando si sono acquisiti i dati di un argomento
			#nello specifico caso si considerano solo gli argomenti con direzione "out"
			def self.argDo
				argDoOut
			end
			#quindi iterare sugli argomenti
			iteratearg(method)

			#stabilisci quale azione eseguire quando è presente almeno un elemento
			#in "ErrorSubset"
			#nello specifico caso si aggiunge alla lista degli argomenti un argomento di errore
			def self.errorDo
					@arglist += @argseparator+"int32_t &p_progerror"
					@argseparator = ", "
			end
			iterateerror(method,true)

			def self.errorDo
					@legalErrorList += "//error return allowed: #{$errornamespace}#{@errorref} - Annotation: #{$error[@errorref][0]}\n"
			end

			iterateerror(method,false)
		end
		#end strategia di scansione di "Method"


		@methodList=""
		#definisce l'azione da compiere prima di attuare la strategia di iterazione su "Method"
		def self.methodDo
			@arglist=""
			@argseparator=""
			@legalErrorList=""
		end

		#definisce l'azione da compiere dopo l'attuazione della strategia di iterazione su "Method"
		def self.methodDoEnd
			@methodList += "\tvirtual int32_t #{@methodname}_imp(#{@arglist}) = 0;\n"
			$methodPrototypeList += "\tint32_t #{@methodname}_imp(#{@arglist});\n"
			$methodSkeletonList += "\n\n#{@legalErrorList}int32_t #{$rootname}_SERVER::#{@methodname}_imp(#{@arglist})\n{\n\tint32_t l_returnedValue=OK;\n\t/* TO BE DONE */\n\treturn (l_returnedValue);\n}\n\n"
		end
		
		#quindi itera sui "Method"
		iteratemethod(interface)


#Signal
		@signalList=""
		#definisci la strategia di iterazione sugli elementi contenuti in "Signal"
		def self.iteratesignalstrategy(signal)
			def self.argDo
				argDoSignal
			end
			iteratearg(signal)
			def self.errorDo
					@arglist += @argseparator+"int32_t &progerror"
					@argseparator = ", "
					@imparglist += @impargseparator+"progerror"
					@impargseparator = ", "
			end
			iterateerror(signal)
		end

		#definisce l'azione da compiere prima dell'attuazione della strategia di iterazione su "Signal"
		def self.signalDo
			@conversionlist=""
			@dbusarglist=""
			@dbusarglistseparator=""
			@arglist=""
			@argseparator=""
		end

		#definisce l'azione da compiere dopo l'attuazione della strategia di iterazione su "Signal"
		def self.signalDoEnd
			signalcode = <<EOS
		void #{@signalname}_imp(#{@arglist})
		{
#{@conversionlist}
			#{@signalname}(#{@dbusarglist});
		}

EOS

			@signalList += signalcode
			$signalPrototypeList += "\tvoid #{@signalname}_imp(#{@arglist});\n"
			$signalSkeletonList += "\tvoid #{$rootname}_CLIENT::#{@signalname}_imp(#{@arglist})\n{\n\t/* TO DO */\n}\n"
			$signalConnectionList += "\tconnect_#{@signalname}();\n"
		end

		#quindi itera sui "Signal"
		iteratesignal(interface)

#Method
		def interfaceDo
			@privatemethodList=""
		end
		def self.iteratemethodstrategy(method)

			#stabilisci quale azione eseguire quando si sono acquisiti i dati di un argomento
			#nello specifico caso si considerano solo gli argomenti con direzione "in"
			def self.argDo
				argDoInDBUS
			end
			#quindi iterare sugli argomenti
			iteratearg(method)

			#stabilisci quale azione eseguire quando si sono acquisiti i dati di un argomento
			#nello specifico caso si considerano solo gli argomenti con direzione "out"
			def self.argDo
				argDoOutDBUS
			end
			#quindi iterare sugli argomenti
			iteratearg(method)

			#stabilisci quale azione eseguire quando è presente almeno un elemento
			#in "ErrorSubset"
			#nello specifico caso si aggiunge alla lista degli argomenti un argomento di errore
			def self.errorDoDBUS
					@arglist += @argseparator+"int32_t &progerror"
					@argseparator = ", "
					@imparglist += @impargseparator+"progerror"
					@impargseparator = ", "
			end
			iterateerror(method)
		end
		#end strategia di scansione di "Method"
		#definisce l'azione da compiere prima di attuare la strategia di iterazione su "Method"
		def self.methodDo
			@arglist=""
			@argseparator=""
			@imparglist=""
			@impargseparator=""
			@declarationList=""
			@assignList=""
			@tmpOutIndex=0
		end

		#definisce l'azione da compiere dopo l'attuazione della strategia di iterazione su "Method"
		def self.methodDoEnd
			@privatemethodList += eval( '"' + @privatemethodtemplate + '"')
		end

		iteratemethod(interface)
	end
end

	